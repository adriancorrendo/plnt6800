{
  "hash": "6000ac476c92c2c94d056e6f84518f0f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Essentials of R coding I\"\nauthor: \"Dr. Adrian Correndo\"\ndate: \"2025-01-10\"\nformat:\n  html:\n    toc: true\n    toc-depth: 4\neditor: visual\n---\n\n\n\n\n\n\n# Introduction\n\nThis page provides an overview of the essential types of elements in R, including examples and explanations for each. Use this as a quick reference to understand the basics of data types and operations.\n\n# Type of elements in R\n\n## 01. Numbers\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n20\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\n\n## 02. Math Operations\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n20+1 # addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\n20-4 # subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\n20*5 # multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\n20/5 # division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n2^2 # exponentials\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(9) # square root\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Greater exponents for roots\n# notation is: x^(1/n)\n\n# Cubic root of 27\n27^(1/3)  # Result: 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4th root of 16\n16^(1/4)  # Result: 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# 5th root of 32\n32^(1/5)  # Result: 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n## 03. Text or characters (also called strings)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"coding is fun\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"coding is fun\"\n```\n\n\n:::\n:::\n\n\n\n\nBut these elements are not stored as objects yet:\n\n## 04. Define objects\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 20\n10 -> b\n# We can also use equal:\nc = 15\n# But using \"<-\", and leave = only for operations (so you can notice the difference) is considered a better coding practice.\n```\n:::\n\n\n\n\n## 05. Print objects\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n\n## 06. Vectors\n\nA vector is one of the most basic data structures. It is a sequence of elements of the same type, such as numbers, characters, or logical values. Vectors are used to store and manipulate collections of data efficiently. <br/>\n\n### a. Creating a vector\n\nVectors can be created using the c() function (combine function):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Numeric vector\nnumeric_vector <- c(1, 2, 3, 4.5)\nnumeric_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 2.0 3.0 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Character vector\ncharacter_vector <- c(\"corn\", \"wheat\", \"soybean\")\ncharacter_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"corn\"    \"wheat\"   \"soybean\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Logical vector\nlogical_vector <- c(TRUE, FALSE, TRUE)\nlogical_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### b. Accessing Elements\n\nYou can access elements of a vector using square brackets \\[\\]:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first element\nnumeric_vector[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access multiple elements\nnumeric_vector[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3\n```\n\n\n:::\n:::\n\n\n\n\n### c. Vectorized Operations\n\nIn R, vector-operations are applied to each element automatically:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adding a scalar to a vector\nnumeric_vector + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 5.0 6.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Element-wise addition\nnumeric_vector + c(10, 20, 30, 40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.0 22.0 33.0 44.5\n```\n\n\n:::\n:::\n\n\n\n\n### d. Common Functions with Vectors\n\n-   **'length()'**: Get the number of elements in a vector.\n-   **'typeof()'** or **'class()'**: Determine the type of elements in a vector.\n-   **'seq()'**: Generate a sequence of numbers.\n-   **'rep()'**: Repeat elements to create a vector.\n\n## 07. Lists\n\nIn R, a list is a versatile data structure that can contain elements of different types, including vectors, matrices, data frames, and even other lists. Unlike vectors, which are homogeneous, lists are heterogeneous, meaning their elements can be of different data types and lengths. <br/>\n\n**Key Characteristics of Lists:** <br/>\n\n1.  Heterogeneous: Lists can store elements of varying types (numeric, character, logical, etc.) and structures (vectors, data frames, functions, etc.). <br/>\n\n2.  Indexed: Elements in a list are accessed using double square brackets \\[\\[ \\]\\] or named elements using \\$.\n\n**Why Use Lists?** <br/>\n\n1.  Flexibility: Lists can store complex and nested data structures. <br/>\n\n2.  Data Wrangling: Useful for handling results from models, nested data, or any mixed-type collections. <br/>\n\n3.  Functions: Functions in R often return their output as lists (e.g., lm()). <br/>\n\n### a. Creating a list\n\nLists are created using the list() function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a list with different types of elements\nmy_list <- list(\n  \"numeric_v\" = numeric_vector,\n  \"character_v\" = character_vector,\n  \"single_number\" = 42,\n  \"logical_value\" = TRUE\n)\n```\n:::\n\n\n\n\n### b. Accessing Elements in a List\n\nYou can access elements in a list by their position or name:\n\nBy Position:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first element\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 2.0 3.0 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access the second element\nmy_list[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"corn\"    \"wheat\"   \"soybean\"\n```\n\n\n:::\n:::\n\n\n\n\nBy name:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access by name\nmy_list$numeric_v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 2.0 3.0 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list$character_v\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"corn\"    \"wheat\"   \"soybean\"\n```\n\n\n:::\n:::\n\n\n\n\nSubelements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first value in the numeric vector\nmy_list$numeric_vector[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\n### c. Some functions for lists\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of elements in the list\nlength(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Names of the elements\nnames(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric_v\"     \"character_v\"   \"single_number\" \"logical_value\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Structure of the list\nstr(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ numeric_v    : num [1:4] 1 2 3 4.5\n $ character_v  : chr [1:3] \"corn\" \"wheat\" \"soybean\"\n $ single_number: num 42\n $ logical_value: logi TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## 08. Data frame\n\nIn R, a data frame is a two-dimensional data structure used for storing tabular data. It is one of the most commonly used data structures in R for data analysis and manipulation. <br/>\n\n**Key Characteristics of a Data Frame** <br/>\n\n1.  Tabular Structure: Data is organized in rows and columns. <br/>\n\n2.  Heterogeneous Columns: Each column can contain different data types (e.g., numeric, character, logical), but all elements in a column must be of the same type. <br/>\n\n3.  Row and Column Names: Rows and columns can have names for easier identification. <br/>\n\n**Why Use a Data Frame?** <br/>\n\n1.  Data Analysis: It is ideal for representing structured data like spreadsheets or databases. <br/>\n\n2.  Flexible Operations: Columns can be easily added, removed, or modified. <br/>\n\n3.  Integration with R Functions: Many R functions for statistical modeling and analysis expect data frames as input. <br/>\n\n### a. Creating a Data Frame\n\nA data frame can be created using the data.frame() function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame\nmy_data <- data.frame(\n  Crop = c(\"Corn\", \"Wheat\", \"Soybean\"), # Character column\n  Yield = c(180, 90, 50), # Numeric column\n  Legume = c(FALSE, FALSE, TRUE) # Logical column\n)\n\nprint(my_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Crop Yield Legume\n1    Corn   180  FALSE\n2   Wheat    90  FALSE\n3 Soybean    50   TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### b. Accessing data in a data frame\n\nAccessing columns:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access a column by name\nmy_data$Crop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Corn\"    \"Wheat\"   \"Soybean\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access a column by index\nmy_data[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 180  90  50\n```\n\n\n:::\n:::\n\n\n\n\nAccessing rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first row\nmy_data[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Crop Yield Legume\n1 Corn   180  FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access specific rows\nmy_data[c(1, 3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Crop Yield Legume\n1    Corn   180  FALSE\n3 Soybean    50   TRUE\n```\n\n\n:::\n:::\n\n\n\n\nAccessing specific elements\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the element in the 2nd row, 3rd column\nmy_data[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access specific cells by column name\nmy_data[2, \"Crop\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Wheat\"\n```\n\n\n:::\n:::\n\n\n\n\n### c. Adding a new column\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data$Season <- c(\"Summer\", \"Winter\", \"Summer\")\n```\n:::\n\n\n\n\n### d. Modify a column\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data$Yield <- my_data$Yield + 5\n```\n:::\n\n\n\n\n### e. Adding a new row\n\nIn base R, we can use rbind() to add rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_row <- data.frame(Crop = \"Barley\", Yield = 80, Legume = FALSE, Season = \"Winter\")\nmy_data <- rbind(my_data, new_row)\n```\n:::\n\n\n\n\n### f. Filtering (rows)\n\nIn base R, we can use subset() to filter rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(my_data, Yield > 150)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Crop Yield Legume Season\n1 Corn   185  FALSE Summer\n```\n\n\n:::\n:::\n\n\n\n\nWe can also use logical conditions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data[my_data$Legume == TRUE, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Crop Yield Legume Season\n3 Soybean    55   TRUE Summer\n```\n\n\n:::\n:::\n\n\n\n\n### g. Selecting (columns)\n\nIn base R, there is no function to select columns. We need to use brackets \\[\\] and vectors c():\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data[c(\"Crop\", \"Yield\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Crop Yield\n1    Corn   185\n2   Wheat    95\n3 Soybean    55\n4  Barley    80\n```\n\n\n:::\n:::\n\n\n\n\n### h. Some functions for data frames\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(my_data)        # Number of rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(my_data)        # Number of columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(my_data)    # Column names\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Crop\"   \"Yield\"  \"Legume\" \"Season\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(my_data)     # Summary statistics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Crop               Yield          Legume           Season         \n Length:4           Min.   : 55.00   Mode :logical   Length:4          \n Class :character   1st Qu.: 73.75   FALSE:3         Class :character  \n Mode  :character   Median : 87.50   TRUE :1         Mode  :character  \n                    Mean   :103.75                                     \n                    3rd Qu.:117.50                                     \n                    Max.   :185.00                                     \n```\n\n\n:::\n:::\n\n\n\n\n## 09. Matrix\n\nIn R, a matrix is a two-dimensional, rectangular data structure that stores elements of the same type. It is similar to a data frame in structure but less flexible, as all elements in a matrix must be of a single data type (e.g., numeric, character, or logical). <br/>\n\n**Key Characteristics of a Matrix** <br/>\n\n1.  Homogeneous: All elements in a matrix must be of the same type. <br/>\n\n2.  2D Structure: A matrix has rows and columns, forming a table-like structure. <br/>\n\n3.  Dimensions: Defined by the number of rows and columns. <br/>\n\n**Why Use a Matrix?** <br/>\n\n1.  Mathematical Operations: Ideal for linear algebra and mathematical modeling. <br/>\n\n2.  Efficient Storage: Matrices use less memory compared to more complex structures like data frames. <br/>\n\n3.  Simpler Operations: Homogeneous data ensures consistent behavior across elements. <br/>\n\n### a. Creating a Matrix\n\nYou can create a matrix using the matrix() function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a numeric matrix\nmy_matrix <- matrix(\n  data = 1:9,     # Data values\n  nrow = 3,       # Number of rows\n  ncol = 3,       # Number of columns\n)\n\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n\n\n\n### b. Accessing elements in a matrix\n\nAccessing rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first row\nmy_matrix[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 4 7\n```\n\n\n:::\n:::\n\n\n\n\nAccessing columns:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the second column\nmy_matrix[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6\n```\n\n\n:::\n:::\n\n\n\n\nAccessing specific elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the element in the 2nd row, 3rd column\nmy_matrix[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n\n\n### c. Adding a new column\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_col <- c(10, 11, 12) # Create the column\nmy_matrix <- cbind(my_matrix, new_col) # Paste it to the existing\n```\n:::\n\n\n\n\n### d. Adding a new row\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_row <- c(13, 14, 15, 16)\nmy_matrix <- rbind(my_matrix, new_row)\n```\n:::\n\n\n\n\n## 10. Functions\n\n### a. Create a function\n\nWe need to use the syntax function(x) { x as object of a task }. 'x' is considered an \"argument\", and the function itself is inside the {}. For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_function <- function(x) { x + 1 }\n```\n:::\n\n\n\n\n### b. Check the function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_function(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n### c. Write a function with 3 arguments\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_xyz_function <- function(x, y, z) { x + y - z }\n```\n:::\n\n\n\n\n### d. Order of arguments\n\n*Note: R is order sensitive (if you don't explicitly specify the argument)*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_xyz_function(12, 3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_xyz_function(12, 4, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13\n```\n\n\n:::\n:::\n\n\n\n\n### e. Specifying arguments with names\n\nIf you specify the argument name as = to, the order doesn't matter:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_xyz_function(z = 4, x = 12, y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n### f. A more complex function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfx <- function(x, y, remove_na = NULL) {\n        # First operation is a sum, removing NAs\n        first <- sum(c(x, y), na.rm = remove_na)\n        # Add a text message\n        text <- \"This function is so cool\"\n        # Store result\n        result <- first + x\n        # Print output\n        print(list(\"Message\" = text,\n                   \"1st\" = first,\n                   \"end\" = result))\n                   }\n```\n:::\n\n\n\n\nRun the function with alternative arguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfx(x = a, y = b, remove_na = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Message\n[1] \"This function is so cool\"\n\n$`1st`\n[1] 30\n\n$end\n[1] 50\n```\n\n\n:::\n\n```{.r .cell-code}\nfx(x = a, y = b, remove_na = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Message\n[1] \"This function is so cool\"\n\n$`1st`\n[1] 30\n\n$end\n[1] 50\n```\n\n\n:::\n:::\n\n\n\n\nStore the output in an object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- fx(x=b, y=a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Message\n[1] \"This function is so cool\"\n\n$`1st`\n[1] 30\n\n$end\n[1] 40\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}