{
  "hash": "243f9ef21de445cc99f8532d03490a0e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iteration in R: The Power of `purrr`\"\nauthor: \"Dr. Adrian Correndo\"\ndate: \"2025-02-12\"\ncategories: [iteration, purrr, functional programming, case study]\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-depth: 4\n    number-sections: true\n    table-class: \"table table-striped table-hover\"\neditor: source\nsmooth-scroll: true\n---\n\n\n\n\n**Description** <br/>\n\nThis lesson explores iteration in R, focusing on the power of the `purrr` package for functional programming. We'll compare traditional `for` loops with `purrr`'s `map()` functions to illustrate more efficient and readable approaches to iteration.\n\n![](https://purrr.tidyverse.org/logo.png){.absolute top=0 right=0 height=\"25%\"}\n\n**Required packages for today** <br/>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pacman) # to install and load packages faster\np_load(dplyr, tidyr) # data wrangling\np_load(purrr) # iteration mapping\np_load(ggplot2) # plots\np_load(agridat) # data\np_load(nlme, broom.mixed, car, performance) # mixed models work\np_load(emmeans, multcomp, multcompView) # multiple comparisons\n```\n:::\n\n\n\n\n# Introduction to Iteration\n\nIteration is a common programming task, typically used to apply a function over elements of a dataset. In R, this can be achieved using:\n\n1. **For loops** (Base R approach)\n2. **`apply()` family functions**\n3. **`purrr` package (Functional programming approach)**\n\n# Traditional `for` Loop Example\n\nThe `for` loop is a straightforward way to iterate over a sequence:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1, 2, 3, 4, 5)\nresults <- numeric(length(numbers))\n\nfor (i in seq_along(numbers)) {\n  results[i] <- numbers[i]^2\n}\n\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\n\n\n# Using `purrr::map()` for Iteration\n\nWith `purrr`, we can achieve the same result in a more elegant and functional style:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's just square the numbers\nlist_output <- map(numbers, ~ .x^2)  # Returns a list\nnumeric_output <- map_dbl(numbers, ~ .x^2)  # Returns a numeric vector\n\nlist_output  # List format\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n```\n\n\n:::\n\n```{.r .cell-code}\nnumeric_output  # Numeric vector format\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\n\n\n# Comparison of For Loops and Mapping Functions\n\n| Feature                | For Loops                               | Mapping Functions (`purrr`)       |\n|------------------------|-----------------------------------------|-----------------------------------|\n| **Ease of Use**        | Straightforward for simple tasks        | More concise, but requires learning `purrr` syntax |\n| **Readability**        | Can become messy with nested loops      | Cleaner and more functional style |\n| **Speed**              | Generally slower for large datasets     | Often faster, especially with parallelization options |\n| **Scalability**        | Less scalable, more prone to errors     | Highly scalable, especially with complex data structures |\n\n\n## Understanding the Difference Between `map()` and `map_dbl()`\n\n- **`map_dbl()`** guarantees that the output is a **numeric vector**.  \n- Similarly:\n  - **`map_chr()`** returns a **character vector**.\n  - **`map_lgl()`** produces a **logical vector**.\n  - **`map_int()`** yields an **integer vector**.  \n- **`map()`**, the most general form, returns a **list** by default.\n\nThese functions are part of an iterative approach where a function is mapped over elements of a list or vector.\n\n# Using the `purrr` Package for Iteration\n\nThe `purrr` package provides several mapping functions to facilitate iteration:\n\n- **`map(x, f)`**: Applies a function `f` to each element of `x`.\n- **`map2(x, y, f)`**: Applies a function `f` to corresponding elements of `x` and `y`.\n- **`pmap(list, f)`**: Applies a function `f` to multiple arguments provided as a list of vectors or data frames.\n\n#### Practical Application\n\nA common workflow involves combining `group_by()` and `nest()` to create nested data frames for iteration. You can then use `mutate()` along with `map()` to apply a function to each nested data frame:\n\n```r\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(tidyr)\n\ndata %>%\n  group_by(group_variable) %>%\n  nest() %>%\n  mutate(results = map(data, your_function))\n```\n\nThis approach is very powerful for applying custom functions to subsets of data efficiently. \n\nLet's see that in practice...\n\n# Working with the `agridat` Dataset\n\nWe will use the `lasrosas.corn` dataset from `agridat` to demonstrate iteration over data frames.\n\n## Load the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_corn_00 <- agridat::lasrosas.corn\nhead(data_corn_00)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year       lat      long yield nitro topo     bv rep nf\n1 1999 -33.05113 -63.84886 72.14 131.5    W 162.60  R1 N5\n2 1999 -33.05115 -63.84879 73.79 131.5    W 170.49  R1 N5\n3 1999 -33.05116 -63.84872 77.25 131.5    W 168.39  R1 N5\n4 1999 -33.05117 -63.84865 76.35 131.5    W 176.68  R1 N5\n5 1999 -33.05118 -63.84858 75.55 131.5    W 171.46  R1 N5\n6 1999 -33.05120 -63.84851 70.24 131.5    W 170.56  R1 N5\n```\n\n\n:::\n:::\n\n\n\n\n## Prepare the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_corn_01 <- data_corn_00 %>% \n  # Select only necessary variables\n  dplyr::select(year, topo, rep, nf, yield) %>% \n  # Group by\n  group_by(year, topo) %>% \n  # Create nested data frames\n  nest(my_data = c(rep, nf, yield))\n```\n:::\n\n\n\n\n## Create functions\n### Rep (block) as fixed\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# SIMPLEST MODEL\nfit_block_fixed <- function(x){\n  lm(# Response variable\n     yield ~ \n       # Fixed (treatment)\n       nf + \n       # Block as fixed too\n       rep,\n     # Data\n     data = x)\n}\n```\n:::\n\n\n\n### Rep (block) as random\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# RANDOM BLOCK (mixed model)\nfit_block_random <- function(x){\n  nlme::lme(# Response variable\n    yield ~\n    # Fixed\n    nf,\n    # Random\n    random = ~1|rep,\n    # Data\n    data = x)\n  }\n```\n:::\n\n\n\n\n## Fit models with mapping\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodels <- data_corn_01 %>% \n  # BLOCK as FIXED \n  mutate(model_1 = map(my_data, fit_block_fixed)) %>% \n  # BLOCK as RANDOM\n  mutate(model_2 = map(my_data, fit_block_random)) %>% \n    \n  # Data wrangling\n  pivot_longer(cols = c(model_1:model_2), # show alternative 'contains' model\n               names_to = \"model_id\",\n               values_to = \"model\") %>% \n  # Map over model column\n  mutate(results = map(model, broom.mixed::augment )) %>% \n  # Performance\n  mutate(performance = map(model, broom.mixed::glance )) %>% \n  # Extract AIC\n  mutate(AIC = map(performance, ~.x$AIC)) %>% \n  ungroup()\n```\n:::\n\n\n\n\n## Model selection\n\nCompare models performance\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visual model selection\nbest_models <- \n  models %>% \n  group_by(year, topo) %>% \n  # Use case_when to identify the best model\n  mutate(best_model = \n           case_when(AIC == min(as.numeric(AIC)) ~ \"Yes\",\n                     TRUE ~ \"No\")) %>% \n  ungroup()\n\n# Plot\nbest_models %>% \n  ggplot()+\n  geom_point(aes(x = model_id, y = as.numeric(AIC), \n                 color = best_model, shape = best_model), \n             size = 3)+\n  facet_wrap(year~topo)+\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](10_iteration_files/figure-html/rm_selection-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Final models\nselected_models <- best_models %>% dplyr::filter(best_model == \"Yes\")\n```\n:::\n\n\n\n\n## Run ANOVA\n\nEstimate the effects of factor under study\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodels_effects <- \n  selected_models %>%\n  # Type 3 Sum of Squares (Partial SS, when interactions are present)\n  mutate(ANOVA = map(model, ~Anova(., type = 3)) )\n\n# Extract ANOVAS\nmodels_effects$ANOVA[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type III tests)\n\nResponse: yield\n              Chisq Df Pr(>Chisq)    \n(Intercept) 5729.92  1  < 2.2e-16 ***\nnf           164.03  5  < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nmodels_effects$ANOVA[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type III tests)\n\nResponse: yield\n              Chisq Df Pr(>Chisq)    \n(Intercept) 6089.64  1  < 2.2e-16 ***\nnf           318.03  5  < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nmodels_effects$ANOVA[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type III tests)\n\nResponse: yield\n            Sum Sq  Df  F value    Pr(>F)    \n(Intercept) 158985   1 7299.604 < 2.2e-16 ***\nnf            1975   5   18.136 4.699e-16 ***\nrep            691   2   15.858 2.509e-07 ***\nResiduals     7841 360                       \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nmodels_effects$ANOVA[[8]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type III tests)\n\nResponse: yield\n                Chisq Df Pr(>Chisq)    \n(Intercept) 18282.200  1  < 2.2e-16 ***\nnf             72.431  5  3.194e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n\n## Means comparison\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# MULTCOMPARISON\n# emmeans and cld multcomp\n# We need to specify ourselves the most important interaction to perform the comparisons\nmult_comp <- \n  models_effects %>% \n  # Comparisons estimates (emmeans)\n  mutate(mc_estimates = map(model, ~emmeans(., ~ nf))) %>% \n  # Assign letters and p-value adjustment (multcomp)\n  mutate(mc_letters = \n           map(mc_estimates, \n               ~as.data.frame( \n                 # By specifies a strata or level to assign the letters\n                 cld(., decreasing = TRUE, details=FALSE,\n                     reversed=TRUE, alpha=0.05,  adjust = \"tukey\", Letters=LETTERS))))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\n```\n\n\n:::\n:::\n\n\n\n\n# Conclusion\n\nIteration is a fundamental skill in data science, and `purrr` provides an expressive, efficient, and tidy approach to iteration. By using `map()`, `map2()`, and `pmap()`, we can iterate over multiple variables seamlessly, avoiding verbose loops while improving readability and maintainability.\n\n### Further Resources\n- [R for Data Science - Iteration](https://r4ds.had.co.nz/iteration.html)\n- [purrr Package Documentation](https://purrr.tidyverse.org/)\n- [Functional Programming in R](https://adv-r.hadley.nz/functionals.html)\n- [agridat Package Documentation](https://cran.r-project.org/web/packages/agridat/agridat.pdf)\n\nHappy coding!",
    "supporting": [
      "10_iteration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}