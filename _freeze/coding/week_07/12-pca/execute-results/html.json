{
  "hash": "4744a367506c22b44ae7c0189b9e4108",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Multivariate Analysis I: PCA in R (tidyverse workflow)\"\nauthor: \"Dr. Adrian Correndo\"\ndate: \"2026-02-04\"\ncategories: [multivariate analysis, PCA, tidyverse, ggplot2, reproducible workflow]\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-depth: 4\n    number-sections: true\n    table-class: \"table table-striped table-hover\"\neditor: source\nsmooth-scroll: true\nbibliography: ../../references.bib\nlink-citations: TRUE\n---\n\n\n\n**Description** <br/>\n\nThis class introduces **Principal Component Analysis (PCA)** as a practical tool for exploring multivariate agronomic datasets. We will use a **tidyverse-style workflow**: tidy data → preprocessing → PCA → tidy outputs → interpretation + visualization (scree plots, score plots, biplots).\n\n**Learning goals** <br/>\n\n- Understand what PCA does (and what it does *not* do).\n- Decide when PCA is appropriate (and when it is not).\n- Run PCA in R using `prcomp()` and **tidy** the results with `broom`.\n- Build a PCA biplot in `ggplot2` (scores + loadings).\n- Avoid common pitfalls: scaling, missing values, outliers, and the “PCA with only 2 variables” trap.\n\n---\n\n# Required packages for today\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pacman)\np_load(\n  dplyr, tidyr, stringr, lubridate, janitor,\n  ggplot2, ggrepel, skimr,\n  broom, tibble, purrr, scales\n)\n```\n:::\n\n\n\n::: callout-tip\n## Reproducibility tip\nIf you simulate data (as we do below), always set a seed.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n```\n:::\n\n\n\n---\n\n# PCA in one paragraph (intuition)\n\nPCA finds **new axes** (principal components) that are linear combinations of your original variables.  \n- **PC1** captures the greatest possible variance.  \n- **PC2** captures the greatest remaining variance, **orthogonal** to PC1.  \n- With *p* variables, PCA produces up to *p* components.\n\n---\n\n# When PCA makes sense\n\nUse PCA when you have:\n\n- Several **numeric** variables (often ≥ 4–5) measured on the same observations\n- Possible **correlation structure** among variables\n- A goal of **exploration**, dimensionality reduction, or summarizing multivariate patterns\n\nAvoid PCA (or be very cautious) when:\n\n- You only have **2 variables** (a scatterplot often communicates more)\n- Variables are on very different scales and you don’t scale/center\n- Many missing values, strong non-linear patterns, or extreme outliers dominate\n\n---\n\n# Mini-case study dataset (agronomy style)\n\nWe’ll build a small dataset that resembles a field trial summary with soil, canopy, and yield/quality variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial <- tibble(\n  site = rep(paste0(\"Site_\", 1:4), each = 30),\n  hybrid = sample(paste0(\"H\", 1:6), size = 120, replace = TRUE),\n  yield_mg_ha = rnorm(120, mean = 11.0, sd = 1.2),\n  protein_pct = rnorm(120, mean = 8.5, sd = 0.6),\n  oil_pct = rnorm(120, mean = 4.2, sd = 0.3),\n  ndvi = pmin(pmax(rnorm(120, mean = 0.78, sd = 0.06), 0.4), 0.95),\n  soil_no3_ppm = rgamma(120, shape = 8, rate = 0.25),\n  om_pct = rnorm(120, mean = 3.5, sd = 0.7)\n) %>%\n  # add some realistic correlation (just for teaching)\n  mutate(\n    yield_mg_ha = yield_mg_ha + 0.03 * soil_no3_ppm + 2.0 * (ndvi - mean(ndvi)),\n    protein_pct = protein_pct + 0.10 * (om_pct - mean(om_pct)),\n    oil_pct = oil_pct - 0.05 * (protein_pct - mean(protein_pct))\n  )\n\ntrial %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 120\nColumns: 8\n$ site         <chr> \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1…\n$ hybrid       <chr> \"H3\", \"H6\", \"H3\", \"H2\", \"H2\", \"H6\", \"H3\", \"H5\", \"H4\", \"H6…\n$ yield_mg_ha  <dbl> 12.604488, 11.199810, 12.694071, 11.599757, 12.630814, 13…\n$ protein_pct  <dbl> 9.340974, 8.315917, 8.847161, 8.274744, 8.136453, 7.90097…\n$ oil_pct      <dbl> 4.525710, 3.809898, 4.383214, 4.056715, 4.425627, 4.21403…\n$ ndvi         <dbl> 0.8072862, 0.8195942, 0.7680066, 0.7412932, 0.7899193, 0.…\n$ soil_no3_ppm <dbl> 36.674506, 19.268982, 31.915381, 31.813683, 40.849757, 31…\n$ om_pct       <dbl> 4.084081, 3.298861, 3.761269, 3.782303, 2.770829, 2.29018…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial %>% skimr::skim()\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |           |\n|:------------------------|:----------|\n|Name                     |Piped data |\n|Number of rows           |120        |\n|Number of columns        |8          |\n|_______________________  |           |\n|Column type frequency:   |           |\n|character                |2          |\n|numeric                  |6          |\n|________________________ |           |\n|Group variables          |None       |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|site          |         0|             1|   6|   6|     0|        4|          0|\n|hybrid        |         0|             1|   2|   2|     0|        6|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|  mean|    sd|   p0|   p25|   p50|   p75|  p100|hist  |\n|:-------------|---------:|-------------:|-----:|-----:|----:|-----:|-----:|-----:|-----:|:-----|\n|yield_mg_ha   |         0|             1| 11.94|  1.26| 8.92| 11.07| 11.79| 12.66| 15.73|▂▇▇▂▁ |\n|protein_pct   |         0|             1|  8.55|  0.58| 7.33|  8.17|  8.49|  8.96|  9.85|▃▇▇▅▃ |\n|oil_pct       |         0|             1|  4.19|  0.31| 3.42|  4.00|  4.21|  4.39|  5.00|▂▅▇▅▁ |\n|ndvi          |         0|             1|  0.79|  0.06| 0.62|  0.75|  0.79|  0.83|  0.93|▁▃▇▆▁ |\n|soil_no3_ppm  |         0|             1| 31.74| 11.04| 5.91| 24.25| 31.14| 39.26| 72.55|▂▇▅▂▁ |\n|om_pct        |         0|             1|  3.55|  0.72| 1.74|  3.19|  3.65|  4.03|  5.38|▂▃▇▅▁ |\n\n\n:::\n:::\n\n\n\n---\n\n# Step 1: Select numeric variables for PCA\n\nPCA requires numeric variables. We typically keep ID columns (site/hybrid) separate so we can label points later.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial_x <- trial %>%\n  select(where(is.numeric))\n\ntrial_ids <- trial %>%\n  select(site, hybrid)\n\ntrial_x %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 120\nColumns: 6\n$ yield_mg_ha  <dbl> 12.604488, 11.199810, 12.694071, 11.599757, 12.630814, 13…\n$ protein_pct  <dbl> 9.340974, 8.315917, 8.847161, 8.274744, 8.136453, 7.90097…\n$ oil_pct      <dbl> 4.525710, 3.809898, 4.383214, 4.056715, 4.425627, 4.21403…\n$ ndvi         <dbl> 0.8072862, 0.8195942, 0.7680066, 0.7412932, 0.7899193, 0.…\n$ soil_no3_ppm <dbl> 36.674506, 19.268982, 31.915381, 31.813683, 40.849757, 31…\n$ om_pct       <dbl> 4.084081, 3.298861, 3.761269, 3.782303, 2.770829, 2.29018…\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n## Scaling choice: covariance vs correlation PCA\n- If variables have very different units (ppm vs % vs indices), use **center + scale** (correlation PCA).\n- If all variables share units and scale is meaningful, you may use only centering.\n- **center\"** = subtract mean; **scale** = divide by standard deviation.\nIn this class we use **center + scale**, so 0 is the mean and values are in units of standard deviations.\n:::\n\n---\n\n# Step 2: Run PCA with `prcomp()` (tidy-friendly)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca_fit <- trial_x %>%\n  prcomp(center = TRUE, scale. = TRUE)\n```\n:::\n\n\n\n---\n\n# Step 3: Tidy the PCA outputs (scores, loadings, variance explained)\n\n## 3.1 Scores (PC coordinates for observations)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores <- broom::augment(pca_fit, data = trial_x) %>%\n  bind_cols(trial_ids) %>%\n  janitor::clean_names()\n\nscores %>% select(site, hybrid, starts_with(\".fitted\")) %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 120\nColumns: 2\n$ site   <chr> \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1\", \"Site_1\", \"Si…\n$ hybrid <chr> \"H3\", \"H6\", \"H3\", \"H2\", \"H2\", \"H6\", \"H3\", \"H5\", \"H4\", \"H6\", \"H6…\n```\n\n\n:::\n:::\n\n\n\n## 3.2 Loadings (how variables contribute to each PC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloadings <- broom::tidy(pca_fit, matrix = \"rotation\") %>%\n  janitor::clean_names() %>%\n  rename(variable = column)\n\n# First 2 dimensions\nloadings %>% filter(pc %in% c(1,2)) %>% arrange(pc, desc(abs(value)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   variable        pc    value\n   <chr>        <dbl>    <dbl>\n 1 yield_mg_ha      1 -0.659  \n 2 soil_no3_ppm     1 -0.648  \n 3 protein_pct      1  0.335  \n 4 om_pct           1 -0.148  \n 5 oil_pct          1  0.107  \n 6 ndvi             1  0.00921\n 7 protein_pct      2  0.557  \n 8 om_pct           2  0.516  \n 9 oil_pct          2 -0.504  \n10 ndvi             2 -0.360  \n11 soil_no3_ppm     2  0.177  \n12 yield_mg_ha      2 -0.0942 \n```\n\n\n:::\n:::\n\n\n\n## 3.3 Variance explained (scree table)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_explained <- tibble(\n  pc = paste0(\"PC\", seq_along(pca_fit$sdev)),\n  sd = pca_fit$sdev,\n  var = sd^2,\n  prop_var = var / sum(var),\n  cum_prop_var = cumsum(prop_var)\n)\n\nvar_explained\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  pc       sd   var prop_var cum_prop_var\n  <chr> <dbl> <dbl>    <dbl>        <dbl>\n1 PC1   1.22  1.48    0.247         0.247\n2 PC2   1.15  1.32    0.220         0.468\n3 PC3   1.03  1.05    0.175         0.643\n4 PC4   0.926 0.857   0.143         0.786\n5 PC5   0.830 0.690   0.115         0.901\n6 PC6   0.771 0.594   0.0990        1    \n```\n\n\n:::\n:::\n\n\n\n---\n\n# Visualization 1: Scree plot + cumulative variance\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_explained %>%\n  ggplot(aes(x = pc, y = prop_var)) +\n  geom_col() +\n  geom_point(aes(y = cum_prop_var, group = 1)) +\n  geom_line(aes(y = cum_prop_var, group = 1)) +\n  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(\n    title = \"Variance explained by principal components\",\n    x = NULL,\n    y = \"Proportion of variance (bars) and cumulative (line/points)\"\n  )\n```\n\n::: {.cell-output-display}\n![](12-pca_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Rule of thumb (exploratory)\nIf PC1 + PC2 explains a modest share (e.g., 50–70%), a 2D plot may still be useful, but don’t over-interpret.  \nIf PC1 + PC2 explains very little, consider 3D, more PCs, or different methods.\n:::\n\n---\n\n# Visualization 2: Score plot (PC1 vs PC2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores %>%\n  ggplot(aes(x = fitted_pc1, y = fitted_pc2, shape = site)) +\n  geom_point(alpha = 0.75) +\n  labs(\n    title = \"PCA score plot\",\n    x = \"PC1 score\",\n    y = \"PC2 score\"\n  ) +\n  theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](12-pca_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n---\n\n# Visualization 3: PCA biplot in ggplot2 (scores + loadings)\n\nA biplot overlays:\n- points = **scores** (observations)\n- arrows = **loadings** (variables)\n\nBecause scores and loadings are on different scales, we apply a simple scaling factor so arrows are visible.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare a small loadings table for PC1/PC2\nloadings_12 <- loadings %>%\n  filter(pc %in% c(1, 2)) %>%\n  select(variable, pc, value) %>%\n  pivot_wider(names_from = pc, values_from = value) %>%\n  rename(loading_pc1 = `1`, loading_pc2 = `2`)\n\n# Scaling factor to make arrows fit the score space\narrow_scale <- scores %>%\n  summarise(\n    scale = min(\n      (max(fitted_pc1) - min(fitted_pc1)) / (max(abs(loadings_12$loading_pc1)) * 2),\n      (max(fitted_pc2) - min(fitted_pc2)) / (max(abs(loadings_12$loading_pc2)) * 2)\n    )\n  ) %>%\n  pull(scale)\n\narrow_scale\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.680948\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nscores %>%\n  ggplot(aes(x = fitted_pc1, y = fitted_pc2)) +\n  geom_point(aes(shape = site), alpha = 0.75) +\n  geom_segment(\n    data = loadings_12,\n    aes(\n      x = 0, y = 0,\n      xend = loading_pc1 * arrow_scale,\n      yend = loading_pc2 * arrow_scale\n    ),\n    inherit.aes = FALSE,\n    linewidth = 0.7,\n    arrow = arrow(length = unit(0.02, \"npc\"))\n  ) +\n  ggrepel::geom_text_repel(\n    data = loadings_12,\n    aes(\n      x = loading_pc1 * arrow_scale,\n      y = loading_pc2 * arrow_scale,\n      label = variable\n    ),\n    inherit.aes = FALSE,\n    size = 4\n  ) +\n  labs(\n    title = \"PCA biplot (scores + loadings)\",\n    x = \"PC1 score\",\n    y = \"PC2 score\"\n  ) +\n  theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](12-pca_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n---\n\n# How to interpret the biplot\n\n**Points (scores)**  \n- Points close together have similar multivariate profiles (in the variables you used).\n- Separation along PC1 suggests differences in the “PC1 gradient.”\n\n**Arrows (loadings)**  \n- Arrow length indicates how strongly a variable aligns with the PC space.\n- The angle between arrows approximates correlation:\n  - small angle → positive correlation  \n  - ~180° → negative correlation  \n  - ~90° → weak/none\n\n**Caution**: Interpretation is only meaningful for variables included, and depends heavily on scaling.\n\n---\n\n# The “PCA with only 2 variables” trap (what your student saw)\n\nIf you run PCA with only **two variables**, you always have two components that span the full 2D space.  \nSo **PC1 + PC2 = 100% variance explained** (by definition). That does *not* mean the PCA is “perfect”; it means you didn’t reduce dimension.\n\n## Quick demo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_vars <- trial %>%\n  select(yield_mg_ha, ndvi)\n\npca_2 <- two_vars %>%\n  prcomp(center = TRUE, scale. = TRUE)\n\n# Here we see 100% variance explained because there are only 2 variables\ntibble(\n  pc = paste0(\"PC\", seq_along(pca_2$sdev)),\n  prop_var = (pca_2$sdev^2) / sum(pca_2$sdev^2)\n) %>%\n  mutate(prop_var = scales::percent(prop_var, accuracy = 0.1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  pc    prop_var\n  <chr> <chr>   \n1 PC1   53.1%   \n2 PC2   46.9%   \n```\n\n\n:::\n:::\n\n\n\n::: callout-important\n## Teaching message\nWith only 2 variables, a **scatter plot** of the standardized variables typically communicates the same information as a PCA biplot, and the “100% variance explained” is expected.\n:::\n\n---\n\n# Optional: A tidy preprocessing pipeline with `recipes` (tidymodels)\n\nIf you want a consistent “data recipe” approach, you can use `recipes` for centering/scaling and PCA.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(recipes)\n\nrec <- recipe(~ ., data = trial_x) %>%\n  step_normalize(all_predictors()) %>%\n  step_pca(all_predictors(), num_comp = 3)\n\nrec_prep <- prep(rec)\npca_scores <- bake(rec_prep, new_data = NULL)   # scores\npca_loadings <- tidy(rec_prep, number = 2)      # loadings for step_pca\n```\n:::\n\n\n\n---\n\n# Common pitfalls checklist\n\n::: panel-tabset\n## Scaling & units\n- If you mix variables in different units (ppm, %, index), use `scale. = TRUE`.\n- Always report whether PCA used covariance or correlation scaling.\n\n## Missing values\n- `prcomp()` does not accept missing values.\n- Options: remove rows, impute, or use specialized PCA methods.\n\n## Outliers\n- PCA is sensitive to outliers.\n- Inspect distributions and consider robust alternatives if needed.\n\n## Interpretation overload\n- PCs are **linear combinations**; avoid forcing causal stories.\n- Use PCA as exploration, then validate with targeted models/experiments.\n:::\n\n---\n\n# In-class exercises\n\n1. **Scaling sensitivity**: run PCA with `scale. = FALSE`. How do the loadings and variance explained change?  \n2. **Variable selection**: drop one variable (e.g., `ndvi`). Does your interpretation of PC1 change?  \n3. **Group structure**: color the score plot by `hybrid`. Do you see separation among hybrids?\n\n---\n\n# Wrap-up\n\nToday you learned a tidy workflow for PCA:\n- select numeric variables\n- scale/center appropriately\n- run PCA (`prcomp`)\n- tidy outputs (scores + loadings + variance explained)\n- visualize and interpret cautiously\n\n**Next class idea**: clustering (k-means or hierarchical) on PCA scores + validation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.2 (2024-10-31)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sequoia 15.6.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Toronto\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] scales_1.4.0    purrr_1.2.0     tibble_3.3.0    broom_1.0.11   \n [5] skimr_2.2.1     ggrepel_0.9.6   ggplot2_4.0.1   janitor_2.2.1  \n [9] lubridate_1.9.4 stringr_1.6.0   tidyr_1.3.1     dplyr_1.1.4    \n[13] pacman_0.5.1   \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.6         generics_0.1.4     stringi_1.8.7      digest_0.6.39     \n [5] magrittr_2.0.4     evaluate_1.0.5     grid_4.4.2         timechange_0.3.0  \n [9] RColorBrewer_1.1-3 fastmap_1.2.0      jsonlite_2.0.0     backports_1.5.0   \n[13] cli_3.6.5          rlang_1.1.6        base64enc_0.1-3    withr_3.0.2       \n[17] repr_1.1.7         yaml_2.3.11        tools_4.4.2        vctrs_0.6.5       \n[21] R6_2.6.1           lifecycle_1.0.4    snakecase_0.11.1   htmlwidgets_1.6.4 \n[25] pkgconfig_2.0.3    pillar_1.11.1      gtable_0.3.6       glue_1.8.0        \n[29] Rcpp_1.1.0         xfun_0.54          tidyselect_1.2.1   rstudioapi_0.17.1 \n[33] knitr_1.50         dichromat_2.0-0.1  farver_2.1.2       htmltools_0.5.9   \n[37] labeling_0.4.3     rmarkdown_2.30     compiler_4.4.2     S7_0.2.1          \n```\n\n\n:::\n:::\n",
    "supporting": [
      "12-pca_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}