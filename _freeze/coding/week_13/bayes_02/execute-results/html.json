{
  "hash": "0e70dbee1eda9ab9314555eda6cd64f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Statistics in R\"\nauthor: \"Dr. Adrian Correndo & Dr. Josefina Lacasa\"\ndate: \"2025-04-02\" \ncategories: [statistics, frequentism, bayes theorem] \neditor: source\nabstract-title: 'Intro' \nabstract: 'This is a follow-up from our \"Intro to Bayesian Statistics\" article. Still, we do have numerous important concepts in order to understand what the computational codes are doing behind scenes when running a Bayesian analysis.'\nformat: \n  html:\n    toc: true\n    toc-location: left \n    toc-depth: 4 \n    number-sections: true \n    table-class: \"table table-striped table-hover\" \n    editor: source \nexecute: \n  echo: true \n  warning: false \n  message: false \nsmooth-scroll: true \n---\n\n\n\n\n\n::: callout-note\n## ğŸ“Œ Today's Topics\n\nWe'll learn how to compute posterior distributions, step-by-step:\n\n1. ğŸ¯ Acceptance/Rejection Sampling (AR Sampling)\n2. ğŸ” Markov Chain Monte Carlo (MCMC) â€” more efficient than AR!\n\nAnd introduce powerful R packages for Bayesian modeling:\n\n3. ğŸ“¦ `brms` â€” beginner-friendly interface to Stan\n4. ğŸ”¬ `rstan` â€” write your own Stan models\n5. ğŸ§ª `rjags` â€” Gibbs sampling with BUGS syntax\n:::\n\n## ğŸ“¦ Packages we'll use today\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(latex2exp)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(brms)\nlibrary(tidybayes)\n```\n:::\n\n\n\n\n## ğŸ² Computing Posterior Distributions\n\n### 1ï¸âƒ£ Acceptance/Rejection Sampling â€” Basics\n\nHere's how AR sampling works:\n\n1. Propose values for parameters\n2. Simulate data based on those values\n3. Measure how well it fits the observed data\n4. Accept if close enough (âœ”ï¸), reject otherwise (âŒ)\n\n#### ğŸŒ½ Simulating Corn Yield vs. Plant Density\n\nWe simulate yield using a parabolic function:\n\n$$ y = \\beta_0 + x \\cdot \\beta_1 - x^2 \\cdot \\beta_2 $$\n\nThen compare simulated data to the real observed values. If the \"fit\" is good enough, we keep those parameter values.\n\nğŸ‘€ We'll visualize which parameter sets are accepted and which aren't!\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n$$ y = \\beta_0 + x \\cdot \\beta_1 - x^2 \\cdot \\beta_2$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.  Generate proposal parameter values **using the prior ditributions**:\n\n$$\\beta_0 \\sim uniform(4, 6)$$\n\n$$\\beta_1 \\sim uniform(1, 3)$$\n\n$$\\beta_2 \\sim uniform(0.1, 2)$$\n\n$$\\sigma \\sim Gamma(2, 2)$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(6767)\nb0_try <- runif(1, 4, 6)  # Parameter model for intercept (Uniform)\nb1_try <- runif(1, 1, 3)  # Parameter model for slope (Uniform)\nb2_try <- rgamma(1, 0.1, 2) # Parameter model for quadratic term (Gamma)\n# Mathematical equation for process model\nmu_try <- b0_try + x*b1_try - (x^2)*b2_try\nsigma_try <- rgamma(1, 2, 2)\n```\n:::\n\n\n\n\n2.  Generate data with those parameters\\\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(567)\ny_try <- rnorm(n, mu_try, sigma_try)  # Process model\n```\n:::\n\n\n\n\n3.  Compare the simulated data with the observed data = \"difference\"\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Record difference between draw of y from prior predictive distribution and\n# observed data\ndiff[k, ] <- sum(abs(y - y_try))\n```\n:::\n\n\n\n\n\n\n4.  \"**Accept**\" (gold) that combination of parameters if the difference \\< predifined acceptable error. \"**Reject**\" (red) if the difference \\> predifined acceptable error.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, y, xlab = \"Plant density\", \n     ylab = \"Corn Yield (Mg/ha)\", xlim = c(2, 13), ylim = c(5, 20),\n     typ = \"b\", cex = 0.8, pch = 20, col = rgb(0.7, 0.7, 0.7, 0.9))\npoints(x, y_hat[k,], typ = \"b\", lwd = 2, \n       col = ifelse(diff[1] < error, \"gold\", \"tomato\"))\n```\n\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/demo 1e-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/demo 1f-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/demo 1g-1.png){width=672}\n:::\n:::\n\n\n\n Now, what if whe change the priors:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/new_priors-1.png){width=672}\n:::\n:::\n\n\n\n\nNow, do many tries\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (k in 1:K_tries) {\n    \n    b0_try <- runif(1, 2, 10)  # Parameter model for intercept as uniform\n    b1_try <- rnorm(1, 2.2, .5)  # Parameter model for slope as normal or gaussian\n    b2_try <- rgamma(1, .25, 2) # Parameter model for quad term as gamma\n    # Mathematical equation for process model\n    mu_try <- b0_try + x*b1_try - (x^2)*b2_try\n    sigma_try <- rgamma(1, 2, 2)\n\n    y_try <- rnorm(n, mu_try, sigma_try)  # Process model\n    \n    # Record difference between draw of y from prior predictive distribution and\n    # observed data\n    diff[k, ] <- sum(abs(y - y_try))\n    \n    # Save unkown random variables and parameters\n    y_hat[k, ] <- y_try\n    \n    posterior_samp_parameters[k, ] <- c(b0_try, b1_try, b2_try, sigma_try)\n}\n```\n:::\n\n\n\n\nAcceptance rate\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(diff < error))/K_tries\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.169531\n```\n\n\n:::\n:::\n\n\n\n\nPriors versus posteriors:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/post_b0-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/post_b1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/post_b2-1.png){width=672}\n:::\n:::\n\n\n\n#### ğŸ“Š Plot predictions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare data\nfiltered_yhat <- y_hat[which(diff < error), 50]\ndf_yhat <- data.frame(pred = filtered_yhat)\n\n# Plot\nggplot(df_yhat, aes(x = pred)) +\n  # Posterior\n  geom_histogram(aes(y = ..density..), fill = \"grey\", color = \"black\", bins = 30) +\n  geom_vline(xintercept = y[50], color = \"gold\", linetype = \"dashed\", linewidth = 1.2) +\n  labs(\n    x = expression(hat(y)[50]),\n    y = \"Density\"\n  ) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/histo-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/plot_1-1.png){width=672}\n:::\n:::\n\n\n\n\nLet's get started\n\n## ğŸ” Markov Chain Monte Carlo (MCMC)\n\n![](images/Handbook.jpg){width=\"241\"}\n\nMCMC methods changed Bayesian stats forever! ğŸ§ ğŸ”¥\n\n- They let us generate samples from **complex** distributions\n- They form a **chain**, where each sample depends on the previous\n- Used in packages like `brms`, `rstan`, and `rjags`\n\nğŸ“š More info:\n- [MCMC Handbook](https://www.mcmchandbook.net/)\n- [MCMCpack](https://cran.r-project.org/package=MCMCpack)\n- [mcmc](https://cran.r-project.org/package=mcmc)\n- [Paper: Foundations of MCMC](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3759243)\n\n::: {align=\"center\"}\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Qqz5AJjyugM\" frameborder=\"0\" allowfullscreen></iframe>\n:::\n\n## `brms`: Bayesian Modeling Made Easy\n\n![](images/brms.png)\n\nğŸ”— Docs: <https://paul-buerkner.github.io/brms/>  \nğŸ› Issues: <https://github.com/paul-buerkner/brms/issues>\n\n`brms` makes it easy to run complex Bayesian models â€” without writing Stan code manually. Itâ€™s inspired by `lme4`, so syntax feels familiar.\n\nIt supports a wide range of models:\n- Linear, GLM, survival, zero-inflated, ordinal, count, and more\n\nâœ¨ Weâ€™ll use `brms` as our go-to interface in this session!\n\nğŸ“š More info:\n- [JSS Article on brms](https://www.jstatsoft.org/article/view/v080i01)\n\n![](images/paste-6C740B97.png){width=\"336\"}\n\n### Fit brms\n\nLet's fit the example using the brms package.\n\n### brms pars\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up pars\nWU = 1000\nIT = 5000\nTH = 5\nCH = 4\nAD = 0.99\n```\n:::\n\n\n\n\n### Model\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 01. Run model\nbayes_model <- \n\n  brms::brm(\n  #Priors\n  prior = c(\n    #B0, Intercept\n    prior(prior = 'normal(8, 8)', nlpar = 'B0', lb = 0),\n    #B1, Linear Slope\n    prior(prior = 'normal(2, 4)', nlpar = 'B1', lb = 0),\n    #B2, Quadratic coeff\n    prior(prior = 'normal(0.001, 0.5)', nlpar = 'B2', lb = 0) ),\n    # Sigma  \n    #prior(prior = 'gamma(15,1.3)', class = \"sigma\") ),  \n    # Population prior (median and sd)\n    \n    # Formula\n  formula = bf(y ~  B0 + B1 * x - B2 * (x^2),\n               # Hypothesis\n               B0 + B1 + B2 ~ 1,\n               nl = TRUE), \n  # Data  \n  data = data_frame, sample_prior = \"yes\",\n  # Likelihood of the data\n  family = gaussian(link = 'identity'),\n  # brms controls\n  control = list(adapt_delta = AD),\n  warmup = WU, iter = IT, thin = TH,\n  chains = CH, cores = CH,\n  init_r = 0.1, seed = 1) \n\n# 02. Save object\n# saveRDS(object = bayes_model, file = \"bayes_model.RDS\")\n\n# Load from file\n#bayes_model <- readRDS(file = \"bayes_model.RDS\")\n\n# 03. Visual Diagnostic\nplot(bayes_model)\n```\n\n::: {.cell-output-display}\n![](bayes_02_files/figure-html/model-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Visualize model results\nbayes_model\n```\n:::\n\n\n\n\n#### Compare vs traditional linear model (lm)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_frame_q <- data_frame %>% mutate(x2 = x^2)\n\nlm(data = data_frame_q, formula = y ~ x + x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + x2, data = data_frame_q)\n\nCoefficients:\n(Intercept)            x           x2  \n      5.415        2.038       -0.114  \n```\n\n\n:::\n:::\n\n\n\n\n### Using posterior distributions\n#### Prepare summary\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create predictions\nm1 <- data_frame %>% \n  ungroup() %>% \n  dplyr::select(x) %>% \n  group_by(x) %>% filter(x == max(x)) %>% \n  ungroup() %>% unique() %>% rename(max = x) %>% \n  # Generate a sequence of x values\n  mutate(data = max %>% purrr::map(~data.frame(\n    x = seq(0,.,length.out = 400)))) %>% \n  unnest() %>% dplyr::select(-max) %>%\n  \n  #add_linpred_draws(m1, re_formula = NA, n = NULL) %>% ungroup()\n  # use \".linpred to summarize\"\n  tidybayes::add_predicted_draws(bayes_model, \n                                 re_formula = NA, ndraws = NULL) %>% ungroup()\n\n# Summarize\nm1_quantiles <- m1 %>% \n  group_by(x) %>% \n  summarise(q025 = quantile(.prediction,.025),\n            q010 = quantile(.prediction,.10),\n            q250 = quantile(.prediction,.25),\n            q500 = quantile(.prediction,.500),\n            q750 = quantile(.prediction,.75),\n            q900 = quantile(.prediction,.90),\n            q975 = quantile(.prediction,.975))\n```\n:::\n\n\n\n\n#### Plot posterior\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot\nm1_plot <- ggplot()+\n  # 95%\n  geom_ribbon(data = m1_quantiles, alpha=0.60, fill = \"cornsilk1\",\n              aes(x=x, ymin=q025, ymax=q975))+\n  # 80%\n  geom_ribbon(data = m1_quantiles, alpha=0.25, fill = \"cornsilk3\",\n              aes(x=x, ymin=q010, ymax=q900))+\n  # 50%\n  geom_ribbon(data = m1_quantiles, alpha=0.5, fill = \"gold3\",  \n              aes(x=x, ymin=q250, ymax=q750))+\n  geom_path(data = m1_quantiles,\n            aes(x=x, y=q500, color = \"brms()\"), size = 1)+\n  geom_point(data = data_frame, aes(x=x, y=y, color = \"brms()\"), alpha = 0.25)+\n  # Add LM curve\n  geom_smooth(data = data_frame, aes(x=x, y=y, color = \"lm()\"),  \n              method = \"lm\", formula = y ~ poly(x,2), se = T, \n              linetype = \"dashed\")+\n  scale_color_manual(values=c(\"purple4\", \"tomato\"))+\n  scale_x_continuous(limits = c(0,12), breaks = seq(0,12, by = 1))+\n  scale_y_continuous(limits = c(4,16), breaks = seq(4,16, by = 1))+\n  #facet_wrap(~as.factor(C.YEAR), nrow = 4)+\n  theme_classic()+\n  theme(legend.position='right', \n        legend.title = element_blank(),\n        panel.grid = element_blank(),\n        axis.title = element_text(size = rel(2)),\n        axis.text = element_text(size = rel(1)),\n        strip.text = element_text(size = rel(1.5)),\n        )+\n  labs(x = \"Plant density (pl/m2)\", y = \"Corn yield (Mg/ha)\")\n\nm1_plot\n```\n:::\n\n\n\n\n## `rstan`: Full Control with Stan\n\n![](images/stanlogo.png){width=\"190\"}\n\nğŸ”— Docs: <https://mc-stan.org/rstan/>  \nğŸ› Issues: <https://github.com/stan-dev/rstan/issues>\n\nStan is a **powerful**, high-performance platform for Bayesian modeling, using:\n- **Hamiltonian Monte Carlo** (HMC)\n- **No-U-Turn Sampler** (NUTS)\n\nUnlike `brms`, Stan requires writing the full model â€” offering full flexibility and speed.\n\nâœ¨ `brms` can even show the Stan code it generates under the hood!\n\nStan also supports Python, Julia, MATLAB, and more.\n\n---\n\n## `rjags`: Just Another Gibbs Sampler\n\n![](images/1601161_JAGS.png){width=\"318\"}\n\nğŸ”— Docs: <https://mcmc-jags.sourceforge.io/>  \nğŸ› Issues: <https://sourceforge.net/projects/mcmc-jags/>\n\n`rjags` uses the classic **Gibbs Sampling** approach and the **BUGS** model syntax (used in WinBUGS, OpenBUGS).\n\n- More manual than `brms`\n- Ideal for users who want to write the full statistical model\n- Often paired with the `coda` package for diagnostics\n\n---\n\nHappy Bayesian coding! ğŸ’»âœ¨",
    "supporting": [
      "bayes_02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}