---
title: "Fundamentals of R Packages"
author: "Dr. Adrian Correndo"
date: "2026-01-14"
format:
  html:
    toc: true
    toc-depth: 4
    toc-location: left
    code-tools: true
editor: source
---

# Introduction

**i. What Are R Packages?**

R packages are collections of functions, data, and documentation that extend the capabilities of R. They are designed to solve specific problems or add functionalities, such as data visualization, statistical modeling, or handling specific types of data.

Analogy: Think of R as a toolbox ðŸ§° and packages as individual tools ðŸ”§ you can add to enhance its utility.

::: callout-important
Core Components:

-   Functions: Ready-made commands to perform tasks.

-   Data: Preloaded datasets for analysis or examples.

-   Documentation: Manuals explaining how to use the package.
:::

**ii. Why Are R Packages Important?**

-   They extend functionality beyond base features.

-   Enable efficient workflows by using pre-written and optimized code.

-   Provide community-contributed solutions for a wide variety of domains (e.g., agriculture, bioinformatics, machine learning).

**iii. Where to Find R Packages?**

-   CRAN (Comprehensive R Archive Network): The primary repository for R packages. Well-maintained and includes thousands of packages.

-   Bioconductor: Specialized in bioinformatics and genomics.

-   GitHub: A platform where developers host and share experimental or in-development packages.

------------------------------------------------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE,message = FALSE)
```

# 01. Managing packages

## a. Installing packages

To install a package from **CRAN**, use:

```{r include=TRUE, eval=FALSE}
install.packages("dplyr")
```

To install a **development** version of a package from **GitHub**, use:

```{r include=TRUE, eval=FALSE}
devtools::install_github("rstudio/ggplot2")
```

Checking installed packages

```{r eval=FALSE}
installed.packages()
```

## b. Loading Packages

Once installed, load a package using:

```{r}
library(dplyr)
```

Or alternatively, you may use packages like `pacman`:

```{r eval=TRUE}
library(pacman)
pacman::p_load(dplyr, ggplot2)
```

Or `easypackages`:

```{r eval=FALSE}
library(easypackages)
easypackages::libraries(dplyr, ggplot2)
```

## c. Updating packages

```{r eval=FALSE}
update.packages()
```

## d. Unload packages

```{r eval=FALSE}
detach("package:ggplot2", unload = TRUE)
```

## e. Uninstall packages

```{r eval=FALSE}
remove.packages("ggplot2")
```

# 02. Documentation

To explore the functions within a package, access the help documentation:

```{r eval=FALSE}
help(package = "dplyr")

# or using the interrogation sign to get help
?dplyr

```

You can also view detailed tutorials or examples using vignetes:

```{r eval=FALSE}
vignette(package = "dplyr")
browseVignettes(package = "dplyr")

```

# 03. Best Packages Practices

## a. Start with the Right Packages:

Use foundational and well supported packages (e.g. [tidyverse](https://www.tidyverse.org), [data.table](https://cran.r-project.org/web/packages/data.table/index.html)).

## b. Stay Curious:

Explore new packages via CRAN Task Views (e.g., [Agriculture Task View](https://cran.r-project.org/web/views/Agriculture.html)).

## c. Version Control:

When becoming an advanced user, you could implement [renv](https://cran.r-project.org/web/packages/renv/index.html) or [packrat](https://rstudio.github.io/packrat/) to manage package versions for reproducible analysis.

# 04. Examples

Let's explore some practical applications of a few packages

## a. agridat

The agridat package contains datasets related to agriculture, such as crop yields, experimental designs, and climate data. Letâ€™s use an example from this package:

```{r}
# Load the package
library(agridat)
# Load an example dataset
data(rothamsted.oats, package = 'agridat')
head(rothamsted.oats)

# view(rothamsted.oats)
```

## b. ggplot2 for data visualization:

```{r}
library(ggplot2)
ggplot(rothamsted.oats, aes(x = trt, y = grain)) +
  geom_point(aes(color = trt))

ggplot(rothamsted.oats, aes(x = trt, y = grain)) +
  geom_boxplot(aes(color = trt))

ggplot(data = rothamsted.oats, 
       aes(x = trt, y = grain, fill = trt)) +
  geom_bar(stat = "identity")+
  facet_wrap(~block)
```

## c. dplyr for data manipulation:

```{r}
library(dplyr)

# Basic dplyr operations
filter(.data = rothamsted.oats, straw > 150)

# Get mean grain yield
summarize(.data = rothamsted.oats, mean_hp = mean(grain))

```

::: callout-note
What if we'd like to run several commands in a row? There are three main options:
1. overwrite an object at each step,
2. create intermediate objects and pass them along, or...
3. use pipe operators to chain commands
:::

## d. Pipe operator '%>%':
The 'dplyr' package heavily utilizes the pipe operator `%>%` from the 'magrittr' package to streamline data manipulation workflows. This operator allows you to pass the output of one function directly into the next function, making your code more readable and easier to follow.
```{r}
# Group by treatment and summarize
# Using the pipe operator for chaining commands
rothamsted.oats %>%
  group_by(trt) %>%
  summarize(mean_grain = mean(grain))

# The best practice is to specify the data using the .data argument
rothamsted.oats %>%
  group_by(trt) %>%
  summarize(.data = ., mean_grain = mean(grain))
```

## e. Native pipe operator '|>':
With the introduction of R 4.1.0, base R now includes its own native pipe operator `|>`, which serves a similar purpose to the `%>%` operator from the 'magrittr' package. This operator allows you to pass the result of one expression as the first argument to the next expression, enhancing code readability without the need for additional packages.

```{r}
# Using the native pipe operator
rothamsted.oats |>
  group_by(trt) |>
  summarize(.data = _, mean_grain = mean(grain))
```
::: callout-warning
Notice when using the `%>%` the placeholder `.` is used to indicate where the piped value should be inserted if it's not the first argument. Similarly, with the native pipe `|>`, the placeholder `_` can be used to indicate where the piped value should be inserted if it's not the first argument.
:::

::: callout-tip
### Does any work â€œbetterâ€ than the other?

#### Where `|>` tends to be better
- No package needed (itâ€™s base R syntax), so it works everywhere without loading magrittr.
- Usually less overhead than %>% because %>% is a function-based pipe, while |> is language syntax.
- In practice, the difference is rarely noticeable compared to the cost of dplyr verbs, but it can matter in tight loops.
-	Plays nicely with modern R style and is increasingly common in new code.

#### Where `%>%` is more flexible
- Placeholder power: %>% uses . to place the LHS wherever you want. Base |> uses _ but itâ€™s more restricted (notably, itâ€™s tied to named arguments).
- `%>%` can do extras like creating functions from a pipeline (and other magrittr variants like `%T>%`, `%<>%`, etc.). Base `|>` doesnâ€™t include those.
- `%>%` lets you pipe into a bare function name (x %>% sqrt). 
- Base `|>` generally requires a call: x |> sqrt()

:::

## f. agricolae

The agricolae package in R is a comprehensive toolset designed for statistical analysis and visualization of agricultural experiments. It is particularly useful for researchers and practitioners working in crop science, agronomy, and other fields of agricultural research.

It provides methods for designing experiments, analyzing experimental data, and visualizing results, particularly for data collected in agricultural and biological research.

::: callout-note
It supports:

-   **Experimental Designs**: Generate designs for field experiments like randomized complete block design (RCBD), Latin square, factorial experiments, and others.

-   **Statistical Analysis**: Analyze variance (ANOVA), perform post-hoc tests (e.g., LSD, Tukey HSD), and assess experimental data.

-   **Visualization**: Create plots for results, including mean comparisons, dendrograms, and histograms.

-   **Agronomic Tools**: Calculate indices like stability for crop yields or pest/disease control measures.
:::

### i. Data analysis

```{r}
# Load agricolae package
library(agricolae)

# Simulate agricultural data
data <- data.frame(
  treatment = rep(c("A", "B", "C"), each = 5),
  yield = c(50, 55, 52, 51, 54,   # Yields for Treatment A
            60, 62, 59, 61, 63,   # Yields for Treatment B
            48, 46, 50, 49, 47)   # Yields for Treatment C
)

# Display the dataset
print(data)

# Perform ANOVA
anova_result <- aov(yield ~ treatment, data = data)
summary(anova_result)

# Perform LSD test for pairwise comparison
lsd_result <- LSD.test(anova_result, "treatment", console = TRUE)
# Could also run Tukey HSD, & Duncan's Test

# Plot LSD results
plot(lsd_result, main = "LSD Test Results for Treatment Yields")
```

### ii. Experimental Design

You can generate layouts for randomized complete block designs (RCBD), Latin squares, Graeco-Latin squares, factorial experiments, and split-plot designs

```{r}
design <- design.rcbd(trt = c("A", "B", "C"), r = 3)
print(design)
```

## g. soiltestcorr

This package assists users on reproducible regression analysis of relationships between crop relative yield (ry) and soil test values (stv) under different approaches.

For example, we can fit a linear-plateu model the a dataset with:

```{r}
library(soiltestcorr)

data_freitas <- soiltestcorr::freitas1966

plot_lp <- linear_plateau(data = data_freitas,
                          stv = STK, ry = RY, plot = TRUE)

plot_lp

plot_qp <- quadratic_plateau(data = data_freitas,
                          stv = STK, ry = RY, plot = TRUE)

plot_qp

# cate-nelson
plot_cn <- cate_nelson_1965(data = data_freitas,
                            stv = STK, ry = RY, 
                            target = 90,
                            plot = TRUE)

plot_cn
```
